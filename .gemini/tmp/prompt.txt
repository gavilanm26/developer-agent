ERES UN ARQUITECTO DE SOFTWARE SENIOR. 
TU MISIÓN: Arreglar el archivo proporcionado respetando ESTRICTAMENTE las reglas del proyecto.

CONTEXTO DEL PROYECTO (REGLAS):
\n--- REGLA (NESTJS_MODULE_RULES.md): ---\n# Reglas: NestJS Gateway Endpoints

## Estructura Obligatoria (Hexagonal-ish)
- Cada endpoint vive en: `src/endpoint/<endpoint-name>` (kebab-case).
- Debe existir `<endpoint-name>.module.ts`.
- Debe existir controller en: `infrastructure/controller`.
- Debe existir service abstract class en: `domain/<endpoint-name>.service.ts`.
- Debe existir adapter abstract class en: `domain/<endpoint-name>.adapter.ts`.
- `application` contiene el `ImplService` (orquestación).
- `infrastructure/adapter` contiene `Ms<Endpoint>Adapter` (consumo a microservicios externos).

## Puertos y Tipado
- Los puertos (Service/Adapter) **SIEMPRE** son `abstract class` con el decorador `@Injectable()`. No usar interfaces.
- Las implementaciones se inyectan en el módulo usando el patrón `{ provide: Service, useClass: Impl }`.\n\n--- REGLA (NESTJS_SERVICE_RULES.md): ---\n# Reglas: NestJS Gateway Service

## Responsabilidades
- El Gateway actúa como proxy y orquestador.
- No contiene lógica de negocio pesada, solo mapeo de peticiones y validaciones.

## Configuración Base (Bootstrap)
- Debe cargar `dotenv`.
- Debe usar `ValidationPipe` global.
- Debe configurar CORS.
- Debe tener `app.module.ts` preparado para inyección dinámica de módulos de endpoint.

## Estructura de Carpetas
- `src/endpoint/`: Contiene todos los módulos que exponen rutas hacia microservicios externos.
- `src/commons/`: Interceptores, Filtros de Excepciones, Loggers compartidos.\n\n--- REGLA (boilerplate-cleanup.md): ---\n# Regla: Limpieza de Boilerplate NestJS

Al inicializar un nuevo microservicio, es OBLIGATORIO eliminar los archivos por defecto que genera el Nest CLI para mantener la arquitectura hexagonal pura desde el inicio.

## Archivos a eliminar:
- `src/app.controller.ts`
- `src/app.service.ts`
- `src/app.controller.spec.ts`

## Ajuste de `app.module.ts`:
El `AppModule` debe quedar vacío de controladores y proveedores iniciales, sirviendo únicamente como el punto de entrada para importar los módulos de los features/microservicios.

```typescript
import { Module } from '@nestjs/common';

@Module({
  imports: [],
  controllers: [],
  providers: [],
})
export class AppModule {}
```\n\n--- REGLA (coding-standards.md): ---\n# Estándares de Código del Agente

Estas reglas deben aplicarse a TODO el código generado por las acciones `create-microservice` y `create-module`.

## 1. General (Node.js)
- **Modularidad:** Usar ES Modules (`import`/`export`) en lugar de CommonJS (`require`), a menos que se especifique lo contrario.
- **Asincronía:** Preferir siempre `async/await` sobre Promesas encadenadas `.then()`.
- **Variables:** Usar `const` por defecto, `let` solo si es necesario. NUNCA usar `var`.

## 2. Estructura de Microservicios
- **Separation of Concerns:**
  - `controllers/`: Manejan la petición HTTP y respuesta.
  - `services/`: Contienen la lógica de negocio pura.
  - `routes/`: Definiciones de endpoints.
- **Manejo de Errores:** Todos los endpoints deben estar envueltos en bloques `try/catch` o usar un middleware de manejo de errores global.

## 3. Naming Conventions
- Archivos: `kebab-case.js` (ej: `user-controller.js`)
- Clases: `PascalCase` (ej: `UserController`)
- Funciones/Variables: `camelCase` (ej: `getUserById`)\n\n--- REGLA (nestjs-hexagonal.md): ---\n# Reglas Maestras: NestJS + Arquitectura Hexagonal

Este documento define la verdad absoluta para la generación de microservicios o features usando NestJS.

## 0. Variables Dinámicas
- `<project_name>`: Nombre del repositorio/proyecto.
- `<service_name>`: Nombre del microservicio (kebab-case).
- `<ServiceName>`: Nombre en PascalCase.

## 1. Estructura de Directorios (NO NEGOCIABLE)
La raíz del feature debe ser: `src/<service_name>/`

| Ruta Relativa | Responsabilidad |
|--------------|-----------------|
| `domain/interfaces/` | DTOs internos del dominio y entidades puras. |
| `domain/ports/` | Contratos (`abstract class`) para Repositorios y Servicios Externos. |
| `application/use-case/` | Lógica de negocio pura (o `application/services`). |
| `application/services/` | Servicios de dominio. |
| `infrastructure/repository/` | **Externo:** Implementación de persistencia (TypeORM, Mongoose). |
| `infrastructure/adapter/` | **Interno:** Implementación de llamadas a otros Microservicios. |
| `infrastructure/controller/` | Entry points (HTTP/REST). |
| `<service_name>.module.ts` | El módulo de NestJS que ensambla todo. |

## 2. Responsabilidades por Capa

### Domain (Puro)
- **Prohibido:** Decoradores de NestJS (excepto `@Injectable` en puertos abstractos).
- **Contenido:** Interfaces, Tipos, Clases de Entidad.

### Application (Orquestación)
- **Inyección:** Usa los puertos abstractos directamente en el constructor.
- **Implementación:** Archivos `*.impl.service.ts`.

### Infrastructure (El mundo real)
- **Repository:** Implementa los puertos de `domain/ports`.
- **Implementación:** Archivos `*.impl.repository.ts`.
- **Controller:** Valida DTOs y llama a Application.

## 3. Convenciones de Código y Patrones

### Inyección de Dependencias (DI)
**REGLA DE ORO:** Usar `abstract class` para los puertos.
- **NO usar interfaces TypeScript** para inyección (evitar Tokens manuales `Symbol`).
- Definición: `export abstract class UserRepositoryPort { ... }`
- Inyección: `constructor(private readonly userRepo: UserRepositoryPort) {}`
- Modulo: `providers: [{ provide: UserRepositoryPort, useClass: UserMongoRepository }]`

### Naming
- Implementaciones: `*.impl.ts` (ej: `user-mongo.impl.repository.ts`).
- Tests: `*.spec.ts` junto al archivo.

## 4. Testing
- Unit tests obligatorios para Services y Controllers.
- Mocks de puertos para aislar capas.

## 5. Checklist de Finalización
1. [ ] ¿Estructura coincide con regla #1?
2. [ ] ¿Puertos son `abstract class`?
3. [ ] ¿Implementaciones terminan en `.impl.ts`?
4. [ ] ¿Tests `.spec.ts` generados?\n\n--- REGLA (nestjs-module.md): ---\n# Reglas para Crear Módulos/Features (NestJS Hexagonal)

Estas reglas aplican al comando `create-module` cuando se trabaja en un proyecto NestJS.

## 1. Definición de Puertos (CRÍTICO)
- **Tipo:** Los puertos en `domain/ports` DEBEN ser `abstract class`.
- **Decorador:** Deben llevar `@Injectable()`.
- **Prohibido:** No usar `interface` para puertos (para aprovechar la DI de NestJS sin tokens manuales).

## 2. Ubicación y Naming
- Ruta: `src/<module_name>/`
- Formato: `kebab-case` para carpetas y archivos.
- Clases: `PascalCase`.

## 3. Estructura Interna del Módulo
Dentro de `src/<module_name>/`:

| Carpeta | Contenido |
|---------|-----------|
| `application/service/` | Lógica de orquestación (Use Cases). |
| `domain/interfaces/` | DTOs de dominio, entidades anémicas. |
| `domain/ports/` | Contratos (`abstract class`) con el mundo exterior. |
| `infrastructure/controller/` | Controladores HTTP/Eventos. |
| `infrastructure/repository/` | **Integraciones EXTERNAS** (DB, APIs Terceros, Cloud). |
| `infrastructure/adapter/` | **Integraciones INTERNAS** (Otros microservicios propios). |
| `infrastructure/repository/helpers/` | Mappers, utilidades de query, etc. |
| `infrastructure/dto/` | DTOs de entrada/salida (Request/Response). |

## 4. Implementación y Sufijos
- **Servicios de Aplicación:** `application/service/<module>.impl.service.ts`
  - *Regla:* Solo habla con `domain/ports`, nunca con infraestructura directa.
- **Repositorios:** `infrastructure/repository/<module>.impl.repository.ts`
- **Adaptadores:** `infrastructure/adapter/<target>.impl.adapter.ts`
- **Module:** `src/<module_name>/<module_name>.module.ts`

## 5. Repository vs Adapter
- **Repository:** Si vas a MongoDB, Redis, S3, o API de un tercero (ej: Stripe).
- **Adapter:** Si vas a llamar a `orders-microservice` (interno) vía HTTP/gRPC.

## 6. Controller
- Solo valida entrada (DTOs con `class-validator`) y llama al servicio de aplicación.
- No contiene lógica de negocio.

## 7. Testing (Obligatorio)
Generar archivo `.spec.ts` adyacente a la implementación.
- 1 spec para `impl.service` (Unitario).
- 1 spec para `impl.repository` / `adapter`.
- Cobertura mínima: Camino feliz + 1 caso de error.

## 8. Definition of Done
1. [ ] Estructura de carpetas creada correctamente.
2. [ ] Puertos definidos como `abstract class`.
3. [ ] Archivos de implementación con sufijo `.impl.ts`.
4. [ ] Módulo creado y providers registrados.
5. [ ] Tests unitarios generados.\n

ARCHIVO A REPARAR (./test-gateway-01/node_modules/@nestjs/schematics/dist/lib/sub-app/files/ts/src/main.ts):
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import * as dotenv from 'dotenv';
import { <%= classify(name) %>Module } from './<%= name %>.module';

async function bootstrap() {
  dotenv.config();

  const app = await NestFactory.create(<%= classify(name) %>Module);

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    }),
  );

  app.enableCors();

  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();

ERROR DETECTADO:
npm error code ENOENT
npm error syscall open
npm error path /Users/gavilan/DEV/Proyectos/developer-agent/package.json
npm error errno -2
npm error enoent Could not read package.json: Error: ENOENT: no such file or directory, open '/Users/gavilan/DEV/Proyectos/developer-agent/package.json'
npm error enoent This is related to npm not being able to find a file.
npm error enoent
npm error A complete log of this run can be found in: /Users/gavilan/.npm/_logs/2026-01-26T23_04_05_633Z-debug-0.log

INSTRUCCIÓN FINAL:
- Devuelve el código COMPLETO y CORREGIDO.
- Respeta la Arquitectura Hexagonal y las convenciones de NestJS del proyecto.
- NO uses bloques de código markdown (sin ```).
- NO intentes usar herramientas (tools) ni expliques nada. Solo entrega el texto del archivo.
